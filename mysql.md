## 隔离级别

当两个及其以上的事务同时发生时，隔离级别定义了一个事务与其他事务在资源或者数据修改方面的隔离程度。隔离级别总共有4种，要更改隔离级别，需要设置 `tx_isolation` 变量，该变量是动态的并具有会话级别的作用范围。

1. 读去未提交（read uncommitted）

   > 当前事务可以读取由另一个未提交的事务写入的数据，这也称为脏读（dirty read）。

2. 读提交 （read committed）

   > 当前事务只能读取另一个事务提交的数据，这也称为不可重复读读取 (non-repeatable read)

3. 可重复读 （repeatable read）

   > 这是MySQL的默认事务隔离级别，它确保同一个事务的多个实例在并发读取数据时，会看到同样的数据行。不过会导致另一个问题——幻读 （Phantom Read）。简单来说，幻读是指当用户读取某一范围时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC， Multiversion Concurrency Control） 机制解决了该问题。
   >
   > ***引用：*** [mysql四种隔离级别](https://www.cnblogs.com/jian-gao/p/10795407.html)

   > MVCC: 当事务开始并执行第一次读去数据时，将创建读取视图并保持打开状态，直到事务结束。为了在事务结束之前提供相同的结果集，InnoDB使用版本控制和UNDO信息。假设事务1选择了几行，另一个事务删除了这些行并提交了数据。如果事务1处于打开状态，它应该能够看到自己在开始时选择的行。已被删除的行保留在UNDO日志空间中以履行事务1.一旦事务1操作完成，那些行便被标记为从UNDO日志中删除。

   

4. 序列化 （serializable）

   > 通过把选定的所有行锁起来，序列化可以提供最高级别的隔离。

**使用：**

​		以读提交为例

> SET  @@transaction_isolation='READ-COMMITTED' 



## 锁

### 内部锁

MySQL在自身服务器内部执行内部锁，以管理多个会话对表内容的争用。

**内部锁分类：**

1. 行级锁

   > 行级锁是细粒度的。只有被访问的行会被锁定。这允许通过多个会话同时进行写访问，使其适用于多用户、高度并发和OLTP的 应用程序。只有InnoDB支持行级锁。

2. 表级锁

   > MySQL对MyISAM、MEMORY和MERGE表使用表级锁，一次只允许一个会话更新这些表。这种锁定级别是得这些存储引擎更使用于只读的或以读取操作为主的或单用户的应用程序。

### 外部锁

MySQL为客户会话提供选项来显示地获取表锁，以阻止其他会话访问表。

1. READ: 当一个表锁定为READ时，多个会话可以从表中读取数据而不需要获取锁。此外，多个会话可以在同一个表上获得锁，因此READ锁也称为共享锁。当READ锁被保持时，不可将数据写入表中。
2. WRITE： 当一个表被锁定为WRITE时，除持有该锁的会话之外，其他任何会话都不能读取或向表中写入数据。因此WRITE也被称为排他锁。

**使用方法：**

```sql
-- 锁定
LOCK TABLES table_name [READ | WRITE]

-- 解锁
UNLOCK TABLES;
```

**锁队列**

除共享锁（一个表可以有多个共享锁）之外，没有两个锁可以一起加在一个表上。如果一个表中已经有一个共享锁，此时有一个排他锁要进来，那么它将被保留在队列中，直到共享锁被释放。当排他锁在队列中时，所有后续的共享锁也会被阻塞并保留在队列中。